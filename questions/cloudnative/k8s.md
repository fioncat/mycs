# k8s知识积累

## k8s是什么？我们为什么需要它？

k8s是一个用于编排管理容器应用的分布式系统。它类似于容器应用的操作系统，可以实现对容器应用的调度、冗灾、滚动升级、网络配置等操作，也就是所谓的容器编排。

在微服务日趋流行的今天，一个系统动辄就要成百上千个服务来支撑，这就对运维维护这些服务带来了很大的压力。我们经过容器化革命已经将这些应用打包成为容器减轻了运维部署的压力，而k8s作为容器应用的管理者，可以实现对容器应用的自动化运维，让海量微服务应用的管理不再是一件困难的事情。

## k8s各个组件以及它们的作用？

k8s总体上由master和worker组成：

- master: 整个k8s的心脏，用于调度、维护集群的元信息
  - api-server：直接和etcd通信，用于处理所有操作k8s资源的请求。
  - scheduler：为pod选择合适的worker运行。
  - controller Manager：包含多个Controller，Controller用于控制k8s资源符合期望的spec，它们会不断调整集群资源以让它们符合用户的期望状态。
- worker：k8s的工作节点，运行pod的实体
  - kubelet：监听api-server，并底层的containerd交互，负责保障容器按照pod中spec指定的状态运行。并且负责向master报告当前节点的健康情况。
  - kube-proxy：负责宿主机的子网管理，并且可以将服务暴露给外部。

## k8s中的pod是什么？我们为什么需要它？

k8s并没有将容器作为调度的最小单元，而是pod，pod是由一组容器组成的，其中的容器共享了一个Network Namespace，并且可以共享Volume。pod中容器的启动是通过infra容器完成的。

为什么需要pod？因为某场景下，一组容器必须是原子调度的，它们是强绑定的。例如服务容器和它的SideCar；或应用容器和它的日志收集程序。使用pod将它们绑定在一起，并作为最小调度单元，会让调度器处理这种超亲密容器非常容易。

而另一种需求是，我们有时候需要一些initContainer来做一些应用启动前的初始化工作，例如进行微服务的配置等。这时候pod的多容器共享网络和储存就能为我们完成这些操作提供方便。

> 容器实际上只是一个进程，它跟虚拟机是完全不一样的。而在容器中使用exec命令运行的程序实际上只是容器进程的子进程，这些子应用是由容器应用fork出来的而不是docker，因此它们实际上是脱管的(docker无法监听或维护它们的状态)。
>
> 很多人喜欢在容器中运行一个supervisor之类进程管理器以在同一个容器中运行多个进程，甚至是使用docker in docker。这实际上是不对的，因为这些进程没有被docker管理，也就无法被k8s管理。正确的做法应该是给pod创建多个容器，每个容器都运行一个服务。

## 简述k8s控制器的原理

控制器实际上使用控制循环来对k8s中的资源进行控制。在对某个资源对象进行控制时，我们需要获取对象的期望状态（一般来源用户定义的spec）；以及该对象的真实状态（来源于集群本身），然后对对象进行操作以让真实状态符合期望状态。

很多控制器是使用一个对象来控制另一个对象，例如Deployment控制ReplicaSet，ReplicaSet控制Pod。

## k8s是如何实现跨主机之间的pod通信的？

## 简述k8s如何通过Service把pod暴露出去的？
