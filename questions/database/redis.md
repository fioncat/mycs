# Redis面试题整理

## 简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点

RDB将当前Redis的数据通过快照储存在磁盘上面。

优点：

- 适合作为冷备，数据快照。在出现故障之后可以恢复到不同版本的数据。
- 不影响Redis主进程，由子进程异步完成备份。
- 恢复大量数据时，RDB只需要将数据重写到内存即可，速度比AOF要快。

缺点：

- 如果Redis发生故障，会丢失最近一次快照只来的所有数据。
- 如果数据量很大，保存快照需要很久的时间，因为需要把所有数据写入到磁盘中。

AOF将所有的写命令以日志的形式追加到AOF文件的结尾。

优点：

- 适合作为热备，如果系统发生故障，数据的丢失比RDB要少。
- AOF文件可以定期压缩，Redis可以对AOF内容进行重写，例如合并某些日志，从而节约AOF占用的空间。
- AOF文件是可读的，我们可以很容易地对它进行分析。

缺点：

- 如果数据量很大，恢复速度比较慢。
- 占用空间比RDB要大。

如何选择持久化：

- 如果不关心数据丢失，可以不持久化。
- 如果可以承受部分数据丢失，可以使用RDB。
- 如果不能承受数据的丢失，可以同时使用RDB和AOF。

## Redis集群的三种复制数据方式

- 主从复制：从数据库启动之后，主数据库发送RDB文件给从数据库让其储存，随后主数据库会发送写命令给从数据库。
  - 优点：可以进行读写分离，让从数据库提供读的操作，主数据库负责进行写入。
  - 缺点：主库或从库宕机之后无法自动恢复，主库宕机之后，因为从库无法负责写入操作，因此整个Redis的写都会失败，必须人工介入将从库切换为主库。
- 哨兵模式：本身还是主从复制，但是多了一个哨兵。哨兵是一个单独的进程，负责控制整个Redis集群。当主机宕机之后，哨兵会切换主机并更新从库的配置。哨兵本身应该也是一个集群以保证高可用。
  - 优点：可以自动切换master的主从模式，集群的可用性更高。
  - 缺点：需要额外的资源支持哨兵集群。
- 集群模式：这不同于主从复制，主从复制将数据储存在所有节点上面，而在集群模式之下，每个Redis节点会储存不同的数据。这就需要对key进行分片储存在不同节点上面。
  - 优点：减轻单个Redis节点储存的数据量。
  - 缺点：当某个节点宕机，部分数据会丢失。

**哨兵的工作模式**

其实有点类似etcd的Raft，哨兵会以一定频率向整个集群中的节点发送PING命令。如果一个节点断线，那么这个节点会被标记为主观下线。当有足够多的哨兵认为一个master节点主观下线，哨兵就会选举出一个新的master节点。

**集群模式**

集群模式下，需要对每个key进行哈希分片，以确认其应该储存在哪个节点上面。这里用到了一致性哈希算法，它的哈希结构是一个环，我们对这个环进行分片。每个分片就是一个槽，当需要数据迁移的时候，可以很方便地进行。

客户端不需要关心集群模式，只需要连接其中任意一个节点即可，如果节点发现数据不在当前机器上面，会自动进行转发。

## 简述 Redis 的过期机制和内存淘汰策略 

Redis一般用来作为缓存数据库，而缓存的数据不能无限增长，否则会导致内存占用过高，因此我们需要key过期机制和淘汰策略来释放内存。

**过期策略**

当为某个key设置TTL之后，在TTL到达以后，有以下的方式将过期的key删除：

- 定期删除：每隔一段时间随机扫描一部分key，发现其中的过期数据。
- 惰性删除：当客户端要获取某个key，而其已经过期了，就会删除它。

但是上面两种方法都会导致内存残留了部分过期的key，导致内存空间的浪费。

> Redis没有提供所谓的定期删除，即当为某个key设置了过期时间，启动一个单独的定时器来监听它，当它过期就执行删除。这种方法会十分消耗CPU资源

所以Redis需要内存淘汰机制来配合过期策略来减少内存空间的浪费。

**内存淘汰策略**

当Redis使用的内存达到某个阈值之后，当有新的key写入时，就会启动内存淘汰：

- noeviction：拒绝所有新的写入操作（默认）。
- allkeys-lru：使用LRU机制淘汰部分最近最少使用的key。
- allkeys-random：随机移除部分key。
- volatile-lru：在设置了过期的key中使用LRU淘汰最少使用的key。
- volatile-random：在设置了过期的key中随机移除key。
- volatile-ttl：在设置了过期的key中优先移除过期时间更早的key。

一般使用LRU比较好，可以提高内存利用率。

## 简述一下Redis的线程模型？

Redis在处理用户请求的时候没有使用多线程，而用到了非阻塞IO以及IO多路复用。

IO多路复用器可以同时连接多个socket，当有某个socket有数据要交互时，就串行地处理它，此时其它socket并没有被阻塞。这样的好处时，在同时连接了多个socket时，只有活动中的socket会被处理，以减少不必要的线程开销。

## Redis为什么要使用单线程来处理请求，为什么在单线程情况下Redis还能这么快？

首先，Redis虽然在处理KeyValue请求的时候是串行处理的，但是它本身并不是单线程的，例如，它也有很多异步的处理流程，例如AOF。

Redis使用IO多路复用来使用一个线程处理多个用户请求，这样空闲的用户请求不会占用额外的资源。这样的问题是，如果一个请求要处理很久，会导致其它请求的饥饿。但是对请求的处理操作都是在内存进行的，因此处理起来很快，所有磁盘的操作都单独设计成了异步的工作模式。

而且Redis本身并不是CPU密集型应用，它主要还是操作内存，因此无法充分利用多核CPU的优势。

此外，采用单线程模式，不需要考虑数据的各种竞态条件，没有加锁带来的开销，没有线程的上下文切换，代码维护起来也更加方便。

所以我们在选择技术方案的时候，并不能说某种方案一定是最好的，一定要根据实际情况综合考虑再做决定。

