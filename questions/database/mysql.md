# MySQL面试题整理

## MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？

B+树本身是一颗多叉树，只有叶子节点储存数据，而所有叶子节点会形成一个双向链表。MySQL使用B+树可以快速实现对某个key或某个范围key的查找，并且因为叶子节点组成了链表，在查找时一般不会涉及到回溯过程，而B树可以将数据储存在所有节点上面，所在在查找时可能会涉及到回溯导致大量的磁盘随机IO。

B+树缺点是必须走到叶子节点才能找到数据，因此在数据量较少时性能比B树要差。

## 数据库的事务隔离级别有哪些？各有哪些优缺点？

有4种隔离级别：

1. 未提交读

不加任何锁，但是可能会产生脏读。即使事务还没有提交，它的修改就会暴露给其他事务。这是最弱的隔离级别，但是性能是最高的。

2. 提交读

这个级别下，一个事务只能读到其他事物提交以后的数据，解决了脏读的问题。但是可能会产生不可重复读的问题，即在同一个事物之内，某个数据在读取第一次之后，被另外一个事务修改了，这时候再读取第二次，值会发生改变。

3. 可重复读

解决了上面可重复读的问题，在同一个事务中，同一个数据不会受到其他事物提交而产生影响。

这解决了数据更新的问题，但是没有解决数据插入的问题，假如某个事务需要对A=1的数据进行更新，更新之后再把A=1的数据查出来。在更新和查数据之间，另一个事务插入了一个A=1的数据，那么第一个事务更新之后查询会发现多出来了一个数据，这就产生了幻读。

4. 串行化

最严格的隔离级别，事务串行运行，但是效率最差。

MySQL实现事务隔离：

使用MVVC实现，一行记录在数据库中可能存在多个版本，版本表示产生这行数据的事务ID。可重复读在进行的时候会创建当前版本的一个全局快照，后面将会一直使用这个数据。而提交读在每次读都会创建一个临时快照。

事务在写的时候，如果写操作能够通过索引找到行，那么会对对应的行加行锁。如果没有索引，会锁住所有行，并在全标扫描时，将不需要更新的行的行锁给释放掉。

MySQL使用间隙锁解决了幻读问题，在对某个数据进行写操作时，会将该行以及它左右间隙（范围）的数据也加锁直到事务完成。这样其它事务就无法影响这些数据了。

## 什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项

事物就是一连串保证了ACID特性的数据库操作。

- A：原子性，所有操作要么一起完成，要么一起失败，没有中间状态。
- C：一致性，事务完成前后，数据都是可用的。这是事务的目标，例如转账操作前后两个账户的和必须相等。
- I：持久性，事务对数据的操作必须是持久化储存的。依靠数据看持久化来实现。
- D：隔离性，讨论了事务之间的隔离程度，有4个隔离级别。

InnoDB实现了ACID事务。所以是默认的。

## 简述乐观锁以及悲观锁的区别以及使用场景

- 悲观锁：每次在获取数据的时候都会加锁。
- 乐观锁：实际上是无锁的，利用CAS原子操作或版本号在更新数据时检查数据是否被他人更新。

乐观锁适用于写较少，读很多的场景。悲观锁适用于写很多的高竞争场景。

## 产生死锁的必要条件有哪些？如何解决死锁？

死锁要产生必须有循环依赖，即某个事务持有A锁，等待B锁；另一个事务持有B锁，等待A锁，它们之间形成了循环依赖，也就产生了死锁。

要解决，可以给所有锁加一个TTL，当时间过了锁还没有释放，进行事务的回滚并自动释放这个锁。或是开启死锁检测，当发生死锁，直接释放事务。

## 聚簇索引和非聚簇索引有什么区别？

聚簇索引将行的所有字段数据放在叶子节点上面，一般聚簇索引都是主键索引。非聚簇索引在叶子节点不存放字段数据，存放主键ID。因此在查询非聚簇索引的数据时可能需要回表到聚簇索引来获取数据的所有字段。

## 索引优化，几种索引失效的场景

几种索引优化的技巧：

- 如果SQL语句对多个字段查询，建议为它们建立关联索引而不是每个字段建立一个索引。如果有多个索引会反复进行回表。但是要注意最左匹配原则避免索引失效。
- 避免冗余索引，例如索引A_B和索引A，实际上索引A是没有必要的。
- 如果查询的数据量很大，而查询的字段比较少，可以考虑建立覆盖索引，将SELECT子句的所有字段加到索引中，以避免回表。
- 在建立索引的时候，对于多种方案，如果查询性能差不多，可以从以后索引的复用情况，或索引字段占用的空间来考虑使用哪种方案。
- 如果索引的区分度集中在前面的字符，例如某种字段的后缀差不多，可以考虑使用前缀索引以减少储存开销。

几种索引失效的场景：

- 对索引字段进行函数操作。
- 字段有隐式的类型转换。
- 使用负向查询例如!=，not in，not like。
- 一个特殊情况，在使用like的时候，如果有'%xxx'这样的匹配，索引会失效，应该使用'xxx%'。
- 在JOIN的时候，注意两张表字段的编码是否相等。(例如utf8和utf8mb4)

另外，在进行ORDER BY的时候，因为索引树是有序的，如果查询语句符合下面要求，就可以在查询之后避免额外的排序：

- WHERE和ORDER BY使用相同的索引。
- ORDER BY顺序跟索引一致。
- ORDER BY都是生序或降序，没有混合。

## 简述一下MySQL的索引下堆

是指储存引擎在处理非主键查询时，服务器会将判断条件传递给储存引擎，储存引擎只返回符合条件的记录，以减少回表的次数。

## JOIN相关优化

JOIN的两种算法：

- NLJ(Index Nested-Loop Join, 嵌套循环联接)：这种方法会先把驱动表中的数据一次性查询出来，然后针对结果每一行都到被驱动表进行查询。如果驱动表很大，这种方法性能会特别差。特别是如果被驱动表用的不是主键索引，则需要大量的回表操作。
- BNL(Block Nested-Loops Join, 基于块的嵌套循环联接)：如果被驱动表JOIN字段没有索引或索引失效。那么驱动表过滤出来的每行数据都要在被驱动表进行一次全表扫描，这是一种灾难，因此MySQL做了一些优化，在扫描驱动表的时候，会把部分或者全部记录储存到一个Join Buffer中，对被驱动表进行扫描时，会直接跟Join Buffer中的所有数据进行匹配，以减少扫描被驱动表的次数。如果Join Buffer把驱动表的所有数据都缓存了，那么被驱动表就只需要扫描一次了。

我们对JOIN优化的目标就是，要尽可能减少被驱动表的扫描次数。在内联查询时，因为关联表顺序可以交换，所以MySQL会帮助我们优化，选择需要扫描次数少的表作为被驱动表。

其次，如果发现MySQL对关联查询用了BNL，就一定要引起警觉，这说明被驱动表没有索引或者索引失效，一定要对被驱动表做合适的优化，尽量使用主键索引或唯一索引。如果无法加索引，应该避免这样的SQL，实在不行就一定要加大join_buffer的容量。

> 上面说的“驱动表大”不是驱动表的数据量，而是指通过SQL语句过滤之后驱动表的记录数量。